"""
code used to make some templates at different scales
"""

from pathlib import Path
import os
import io
from subprocess import run
import gzip
import zlib

import numpy as np
from attr import evolve
import napari

from registration_pipeline.registration_config import (
    TemplateImageInfo,
    OpticLobeCondition,
    find_cmtk,
    RegistrationConfig,
)
from registration_pipeline.napari_plugin import save_nhdr

IDENTITY_XFORM = """! TYPEDSTREAM 2.4

affine_xform {
	xlate 0 0 0 
	rotate 0 0 0 
	scale 1 1 1 
	shear 0 0 0 
	center 44 60.4 51.4 
}"""

NHDR_FILE = '''NRRD0005
# This NRRD file was generated by pynrrd
# on 2024-05-09 06:12:17(GMT).
# Complete NRRD file format specification at:
# http://teem.sourceforge.net/nrrd/format.html
type: uint16
dimension: 3
sizes: {xpix} {ypix} {zpix}
endian: little
encoding: gzip
data file: dat.raw.gz
space dimension: 3
space directions: ({xscale},0,0) (0,{yscale},0) (0,0,{zscale})
space units: "microns" "microns" "microns"
kinds: domain domain domain
labels: "x" "y" "z"'''


def save_mask(data: np.ndarray, path: Path) -> int:
    """
    saves a mask in a compressed form
    """
    buffer = io.BytesIO()
    ndims = np.array([len(data.shape)]).astype("<u8")
    buffer.write(ndims.tobytes())
    shape = np.array(data.shape).astype("<u8")
    buffer.write(shape.tobytes())
    packed_array = np.packbits(data.astype(bool))
    buffer.write(packed_array.tobytes())
    byte_data = buffer.getvalue()
    compressed_byte_data = zlib.compress(byte_data, zlib.Z_BEST_COMPRESSION)
    return path.write_bytes(compressed_byte_data)


def load_mask(path: Path) -> np.ndarray:
    """
    loads a mask from its compressed form
    """
    compressed_byte_data = path.read_bytes()
    byte_data = zlib.decompress(compressed_byte_data)
    buffer = io.BytesIO(byte_data)
    ndim_bytes = buffer.read(8)
    (ndims,) = np.frombuffer(ndim_bytes, dtype="<u8")
    shape_bytes = buffer.read(int(ndims * 8))
    shape = np.frombuffer(shape_bytes, dtype="<u8")
    packed_array = np.frombuffer(buffer.read(), dtype=np.uint8)
    out = np.unpackbits(packed_array).reshape(shape)
    return out


def test_example():
    from skimage import data
    import napari

    blobs = (
        data.binary_blobs(
            length=20, blob_size_fraction=0.3, volume_fraction=0.02, n_dim=3
        )
        * 254
    ).astype(np.uint8)
    template = napari.layers.Image(blobs, scale=(0.38, 0.38, 0.38))
    left_mask = np.zeros(blobs.shape).astype(bool)
    right_mask = left_mask.copy()
    left_mask[:, :, 10:] = True
    right_mask[:, :, :10] = True
    ol_conditions = ["none", "left", "right", "both"]
    dims = [(0.5189161, 0.5189161, 1.0), (0.38, 0.38, 0.38), (0.1, 0.1, 0.2)]
    tiis = [TemplateImageInfo(*dim, olc) for olc in ol_conditions for dim in dims]
    for layer in viewer.layers:
        if layer.name[0] == 3:
            layer.scale = (0.38, 0.38, 0.38)
        else:
            layer.scale = (1, 0.5189161, 0.5189161)


def make_images(
    template: napari.layers.Image,
    left_mask: np.ndarray | None,
    right_mask: np.ndarray | None,
    tiis: list[TemplateImageInfo],
):
    """
    rerenders all of the images at the required resolutions

    template is the template image to manipulate
    left_mask, right_mask is boolian arrays for left and right optic lobe
    ol_conditions are which optic lobes should be present. Use both if masks do not exist
    temp
    asserts that cwd is the correct template dir

    """
    template_tii = TemplateImageInfo(
        template.scale[2], template.scale[1], template.scale[0], "both"
    )
    Path("original-path").write_text(str(template_tii.to_path()), "utf-8")
    # handle optic lobes on original image
    for ol_condition in np.unique([tii.optic_lobe_condition for tii in tiis]):
        data = template.data.copy()
        if ol_condition == "both":
            pass
        if ol_condition in ("left", "none"):
            if left_mask is None:
                raise ValueError("left mask is necessary")
            data[left_mask] = 0
        if ol_condition in ("right", "none"):
            if left_mask is None:
                raise ValueError("right mask is necessary")
            data[right_mask] = 0
        new_tii = evolve(template_tii, optic_lobe_condition=ol_condition)
        save_nhdr(
            napari.layers.Image(data, scale=template.scale), Path(), new_tii.to_path()
        )
    # handle scaling
    config = RegistrationConfig(Path(), find_cmtk(), Path(), os.cpu_count())
    xform_path = Path("identity-xform")
    xform_path.write_text(IDENTITY_XFORM, "utf-8")
    dummy_raw_path = Path("dat.raw.gz")
    old_raw_size = 0
    for tii in tiis:
        scaled_pix = np.ceil(
            template.data.shape[::-1] * template_tii.xyz() / tii.xyz()
        ).astype(int)
        out_header = NHDR_FILE.format(
            xpix=scaled_pix[0],
            ypix=scaled_pix[1],
            zpix=scaled_pix[2],
            xscale=tii.x_scale,
            yscale=tii.y_scale,
            zscale=tii.z_scale,
        )
        new_raw_size = np.prod(scaled_pix)
        if new_raw_size > old_raw_size:
            new_array = bytes(new_raw_size * 2)
            ziped_bytes = gzip.compress(new_array)
            dummy_raw_path.write_bytes(ziped_bytes)
        fixed_path = Path("fixed_path")
        fixed_path.write_text(out_header)
        floating_tii = evolve(
            template_tii, optic_lobe_condition=tii.optic_lobe_condition
        )
        assert floating_tii.to_path().exists()
        args = (
            config.get_cmtk_exe("reformatx"),
            "--cubic",
            "--outfile",
            tii.to_path(),
            "--floating",
            floating_tii.to_path(),
            fixed_path,
            xform_path,
        )
        run(args, check=True)
    xform_path.unlink()
    dummy_raw_path.unlink()
    fixed_path.unlink()
